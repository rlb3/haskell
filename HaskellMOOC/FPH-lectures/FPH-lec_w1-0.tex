%-----------------------------------------------------------------------
% Functional Programming 4
% John O'Donnell, Wim Vanderbauwhede
%-----------------------------------------------------------------------

\documentclass{beamer}
%include polycode.fmt
%format alpha = "\alpha"
%format ~> = "\leadsto "
\usepackage{jtodlecseriesFP4}
\usepackage{url}
% Identify this presentation
\SetPresentationTitle
  {Introduction}
  {Learn Functional Programming: \\Introduction to Programming in Haskell \\-- Introduction}
\SetPresentationNumber
  {1}
\SetPresentationDate
  {Week 1-1}
  {Week 1-1}

%-----------------------------------------------------------------------
% Beginning

\begin{document}

\begin{frame}
  \PresentationTitleSlide
\end{frame}

\begin{frame}
 \frametitle{Topics}
 \tableofcontents
\end{frame}


%-----------------------------------------------------------------------

%WV: This should be the dragon and it should come much earlier!
\begin{frame}
\begin{center}
\includegraphics[scale=0.35]
	{figures/jpg/pic09.jpg}
\end{center}
\end{frame}
%-----------------------------------------------------------------------

\section{The Course}

\begin{frame}
\frametitle{The subject of "Learn Functional Programming"}

\begin{itemize}
\item Principles, practice, and (a little) theory of pure
  functional programming
\item Study Haskell, the most widely used functional language
%\item Go deeply into the language, its tools, and its libraries
\item Master the fundamental techniques, including recursion,
  combinators, algebraic data types, equational reasoning, and
  monads.
\item Learn how to write substantial practical programs.
\item Introduce some recent developments and powerful techniques in
  programming: data/task parallelism, software transactional
  memory, automatic testing, generic programming, metaprogramming,
  exotic types.
\end{itemize}
\end{frame}
%-----------------------------------------------------------------------
\begin{frame}
\frametitle{Approach}

\begin{itemize}
\item There are many functional languages.
\item We will focus on Haskell, which is arguably the most
  important functional language (both for research and practical
  applications)
\item The course will begin at the beginning (although we assume you know at least one other programming language)
\item The course will move quickly and get into advanced and powerful
  techniques

\end{itemize}

\end{frame}

%-----------------------------------------------------------------------

%-----------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{The FutureLearn page}

\begin{itemize}
\item The FutureLearn course page will contain lecture slides, exercises,
  software, pointers to further reading, and announcements.
\item Here is the direct URL:
\end{itemize}

%\begin{verbatim}
\url{https://www.futurelearn.com/courses/functional-programming-haskell}
%\end{verbatim}

\end{frame}
%-----------------------------------------------------------------------
%\begin{frame}
%\frametitle{Assessment}
%
%\begin{itemize}
%\item FP4 is assessed through coursework (20\%) and exam (80\%).
%\item There will be one mandatory assessed exercise 
%\item and one \emph{optional} assessed exercise.
%\item If you only do the mandatory assessed exercise it is worth 20\%;
%\item if you do both, the mandatory assessed exercise is 15\% and the optional one 5\%.
%\end{itemize}
%
%\end{frame}

%-----------------------------------------------------------------------
\section{Programming paradigms}

\begin{frame}
\frametitle{Programming paradigms}

There are several major programming paradigms:

\begin{itemize}
\item {\bluetext Imperative languages.}  A program is a set of
  commands telling the computer what to do; by obeying the commands
  the computer solves the problem.
  \begin{itemize}
  \item {\bluetext Basic imperative languages} {\redtext (Fortran,
      Algol60, PL/I, Algol68, C, Pascal, $\ldots$)}
  \item {\bluetext Object oriented languages} {\redtext (Simula67,
      C++, Objective C, Java, $\ldots$)}
  \end{itemize}
\item {\bluetext Declarative languages.}  A program is a
  mathematical description of the solution to a problem; by
  simplifying the description the computer solves the problem.
  \begin{itemize}
  \item {\bluetext Impure functional languages} {\redtext (Lisp,
      ML, Caml, MetaOCaml, $\dots$)}
  \item {\bluetext Pure functional languages} {\redtext (Lisp, FP,
      SASL, KRC, Miranda, Haskell, $\dots$)}
  \item {\bluetext Logic languages} {\redtext (Prolog, Mercury,
      $\ldots$)}
  \end{itemize}
\end{itemize}

\end{frame}
%-----------------------------------------------------------------------
\section{Functional Languages}
\begin{frame}
\frametitle{What are Functional Languages?}

\begin{itemize}
%\item The main current activity in logic languages is how to integrate them with functional languages.
\item There are three main families of functional languages
\item Each family has produced a sequence of experimental
  languages; the most important current one is emphasised:
  \begin{itemize}
  \item Untyped impure: Lisp, {\bluetext Scheme, LiveScript}
  \item Typed impure: ML, Standard ML, {\bluetext OCaml}
  \item Typed pure: ISwim, FP, SASL, KRC, Miranda, {\bluetext
      Haskell}
  \end{itemize}

\item Haskell was designed by the (academic) pure FP community, to enable everyone to use the same basic language design.
\item There are many others, e.g. LiveScript was designed by a community of people who need JavaScript but prefer functional programming.
\end{itemize}

\end{frame}
%-----------------------------------------------------------------------


%\begin{frame}
%\frametitle{What is LiveScript like?}
%
%\begin{itemize}
%\item A small set of general foundational features; everything
%  else is built on top of them.
%\item LiveScript programs tend to be shorter than programs in
%  languages like Java, JavaScript and C++ (sometimes as much as a factor of
%  10).
%\item It's ``dynamically typed'': you generally don't think much about the types of objects.
%\item A central theme in LiveScript is ease of use, obtained through abstraction.
%\end{itemize}
%
%\end{frame}
%-----------------------------------------------------------------------

\begin{frame}
\frametitle{What is Haskell like?}

\begin{itemize}
\item A small set of general foundational features; everything
  else is built on top of them.
\item Haskell programs tend to be shorter than programs in
  languages like Java and C++ (sometimes as much as a factor of
  10).
\item It's ``typeful'': you typically spend half or more than half
  of your time thinking about types.
\item The rich type system requires a lot of thought, but it
  greatly simplifies programming
\item Many errors that would be runtime bugs in other languages are
  caught by the Haskell compiler
\item A central theme in Haskell is abstraction
\item Haskell has a mathematical flavour, and you can use
  mathematics to prove correctness, improve efficiency, and derive
  programs.
\end{itemize}

\end{frame}

%-----------------------------------------------------------------------
\begin{frame}
\frametitle{Pure functional programming}

\begin{itemize}
\item Haskell is \emph{functional}.
  \begin{itemize}
  \item Functions are ``first class'' --- they are ordinary values.
  \item Higher order functions allow the definition of combinators,
    which are something like user-defined language constructs.
  \end{itemize}
\item Haskell is \emph{pure}
  \begin{itemize}
  \item There are no \emph{side effects}.
  \item You don't compute by modifying variables; you compute by
    calculating new values.
  \item Programs are expressions defined with equations and
    functions; programs are executed by \emph{reducing the
      expressions}.
  \item Equations mean real mathematical equality; they are not
    assignment statements.
  \item Haskell is closely related to mathematics.
  \end{itemize}
\end{itemize}

\end{frame}

%-----------------------------------------------------------------------
%-----------------------------------------------------------------------
\begin{frame}
  \frametitle{Functional languages are used in industry}

\begin{itemize}
\item Commercial Users of Functional Programming (CUFP) workshop
  has been meeting annually since 2004 --- {\bluetext @www.cufp.org@}
  \item {\bluetext Intel} uses functional programming for {\redtext
      digital circuit design}
  \item {\bluetext Facebook} uses Haskell for some projects
  \item Galois uses Haskell for {\redtext cryptography}
  \item Several major {\bluetext banks} use Haskell for {\redtext
      financial modeling of derivatives}
  \item Metaweb uses fp for {\redtext web database}
  \item {\bluetext Ericson} uses Erlang for {\redtext telephone
      switching systems}
  \item {\bluetext Microsoft} is incorporating functional
    programming into {\redtext F\#} and {\redtext Visual Studio},
    and some fp concepts are in {\redtext C\#}
  \item SSH uses fp for {\redtext communication security software}
  \item Liveops uses OCaml for a {\redtext Network Services
      Platform}
  \item LiveScript is used in production by SocialText and import.io.      
  \item And many more $\ldots$
\end{itemize}

\end{frame}

%-----------------------------------------------------------------------
\begin{frame}
\frametitle{Haskell is used in research}

\begin{itemize}
\item Functional programming is central to modern research in
  programming languages
\item Haskell has far more research activity than other functional
  languages
\item Most programming language research is about a specific topic,
  not just designing a new language
\item Usually these new topics are explored in functional
  languages, most often in Haskell
\item Some {\bluetext current hot topics:}
  \begin{itemize}
  \item Dependent type systems
  \item Software transactional memory
  \item Task and data parallelism
  \item Hot plugins
  \item Automatic test generation
  \item Correctness proofs of safety-critical software
  \item Metaprogramming
  \item Domain specific languages
  \end{itemize}
\end{itemize}

\end{frame}

%-----------------------------------------------------------------------
\begin{frame}
\frametitle{Programming language concepts}

Many concepts that were developed in functional programming have
been adopted by imperative languages.  (Dates are approximate)

\begin{itemize}
\item Automatic storage management and garbage collection (now in
  Java)
  \begin{itemize}
  \item Lisp, 1960
  \end{itemize}
\item Higher order functions (now in Python)
  \begin{itemize}
  \item Lisp (1960), ISwim (1965), Scheme (1975)
  \end{itemize}
\item Polymorphism (now in Java, C++)
  \begin{itemize}
  \item ML
  \end{itemize}
\item Algebraic data types
  \begin{itemize}
  \item Miranda (1985)
  \end{itemize}
\item Metaprogramming (now in C++)
  \begin{itemize}
  \item Lisp, Planner, Conniver, Scheme, MetaOCaml, Haskell
  \end{itemize}
\item Concurrency with software transactional memory
  \begin{itemize}
  \item Haskell (2005)
  \end{itemize}
\end{itemize}

\end{frame}

%-----------------------------------------------------------------------
\begin{frame}
\frametitle{A bit of history}

\begin{itemize}
\item Functional programming has deep ties to mathematics and
  philosophy.
\item Some if its central concepts were discovered by
  mathematicians in the early and mid 20th century.
\item There is a very deep mathematical theory underlying
  functional programming, consisting of several branches of
  mathematics (predicate logic, lambda calculus, combinatory logic,
  domain theory, denotational semantics, and category theory).
  \begin{itemize}
  \item Don't worry---you don't have to know any of these!
  \end{itemize}
\item The main focus of FP4 is on practical programming and
  advanced techniques
\item But we'll take a little look at some of these other issues,
  to appreciate the richness of the culture of functional
  programming.
\end{itemize}

\end{frame}

%-----------------------------------------------------------------------
\begin{frame}
\frametitle{Famous people}

A very incomplete list of some of the founders of the subject: 

\begin{itemize}
\item Moses Sch\"onfinkel (1889--1942), discovered combinatory
  logic and the technique known as ``currying''.  You'll use
  currying every day, and the Haskell compiler uses a modified form
  of combinatory logic as it translates your program to machine
  language.
\item Alonzo Church (1903--1995), invented the lambda calculus,
  which is the foundation of all functional languages.
\item John Rosser (1907--1989) collaborated with Church, and
  together they proved the \emph{Church-Rosser theorem}, which is
  central to reliability of functional languages, and is the
  fundamental reason that Haskell is considered a leading candidate
  for parallel programming on multicore chips.
\item Haskell Curry (1900--1982) developed combinatory logic
  further, giving it the flexibility that was later exploited by
  functional languages.  \emph{The language Haskell was named after
    him, with the approval of his widow.}
\end{itemize}

\end{frame}


\end{document}
